classdef Figure4 < Figure
    % eWLC sweep of a simulated dataset, showing that the 'conventional'
    % way of fitting the eWLC model [which has a functional dependence of
    % d(F)] leads to a dependence of fit results on the selection of the
    % range of data to fit. This is resolved with the 'new' way of fitting,
    % which involves rewriting the model to express F(d) (since in OT data,
    % the most significant errors are in F).

    properties

        % ----- Parameters

        % Handle to a function that generates a simulated dataset based
        % on the Odijk model.
        simulDataFun            = @(Lp, Lc, S) simulatefddata(...
                                            'model', 'odijk', ...
                                            'modelParams', {Lp Lc S} ...
                                            );

        % Persistence length value (nm) to use for the simulated dataset.
        simulLp                 = 50;

        % Contour length value (um) to use for the simulated dataset.
        simulLc                 = 16.5;

        % Stretch modulus (pN) to use for the simulated dataset.
        simulS                  = 1500;

        % What parameter are we plotting in this figure?
        % String, either 'Lp' or 'S'.
        plotParam               = 'Lp';

        % Vector [min max] (in um), indicating between which values
        % "Dmin" is swept. In other words: we fit only the data
        % "d > Dmin", where Dmin is varied between the two values in
        % this vector.
        sweepBoundaries         = [10 15.5];

        % Size of the steps to take between the boundaries given in
        % the "sweepBoundaries" property (in um).
        sweepStep               = 0.1;

        % Y limits in the main plot.
        YLims                   = [0 100];

        % Use to make the figure reproducible. Set to [] (empty array)
        % to disable this behavior, and generate different versions of
        % the Figure than the one in the paper.
        randomSeed              = 1985;

        % The simulated data curve that we're fitting the model to.
        % Generated by "generateData" (as an FdData object).
        fittedData              = [];

    end

    properties (SetAccess = private)

        % Results of the sweeps.
        % Struct with two fields, "brokenFits" and "correctFits";
        % these correspond to fitting the data the incorrect way
        % and the correct way, respectively.
        % Each of the two sub-structs has the following layout:
        %   .sweepPosL = vector with the actual values of Dmin used.
        %   .Lp = values found for the persistence length in each of
        %           the sweep fits (vector with the same length as
        %           "sweepPosL").
        %   .err = values found for the goodness-of-fit.
        %   .exitflag = "exit flags" of MATLAB's "fit" function for each
        %           of the fits.
        sweepResults            = [];

        % Axes handle to the main plot.
        axes_main               = [];

        % Axes handle to the inset plot.
        axes_inset              = [];

    end % properties

    % ------------------------------------------------------------------------

    methods

        function [self] = Figure4(varargin)
            self = self@Figure(varargin{:});
        end

        function generateData(self)
            % GENERATEDATA Generate simulated data.
            %
            % This is normally only done once. Call this method manually to
            % generate a new dataset.

            self.fittedData = self.simulDataFun(...
                                    self.simulLp, self.simulLc, ...
                                    self.simulS ...
                                    );
        end

        function analyze(self)
            % ANALYZE Perform calculations.

            if ~isempty(self.randomSeed)
                fprintf('Setting random seed to %g, for reproducible figure.\n', self.randomSeed);
                rng(self.randomSeed);
            end

            if isempty(self.fittedData)
                self.generateData();
            end

            %% Do sweeps
            self.sweepResults = struct();
            disp('Sweeping broken fits...');
            self.sweepResults.brokenFits = ...
                    self.doSweep(...
                        @(fd) fitfd_improper(fd, 'model', 'odijk-d0-f0', 'notrim') ...
                        );
            disp('Sweeping correct fits...');
            self.sweepResults.correctFits = ...
                    self.doSweep(...
                        @(fd) fitfd(fd, 'model', 'odijk-d0-f0', 'notrim', 'Lc', 16.5) ...
                        );
        end


        function [res] = doSweep(self, fitFun)
            % DOSWEEP Performs a 'sweep', a series of fits for varying Dmin

            %% Set up
            % The idea here is to test what the effect is of selecting a
            % particular subset of datapoints for the fit. We'll see that
            % for the 'conventional' fitting approach (= fitting the d(F)
            % representation of the eWLC model), we get a strong dependence
            % of the fit results on data selection. This is resolved by
            % fitting the 'inverted eWLC', which has F(d) [F as a function of
            % d].
            %
            % 'sweepPosL' is the left boundary of the range of data
            % we're using for the fit, with respect to the distance axis.
            sweepPosL = self.sweepBoundaries(1,1):self.sweepStep:self.sweepBoundaries(1,2);

            % How many fits we have to do (per axis, and in total)
            nSweeps = length(sweepPosL);

            % For each position in the grid, store the boundaries, for
            % easier access.
            sweepBounds = cell(nSweeps,1);
            for i = 1:length(sweepPosL)
                sweepBounds{i} = sweepPosL(i);
            end


            %% Go!
            % Fetch the simulated dataset we're using for the fit
            fd = self.fittedData;

            % Store fit results in a (linearized) cell array
            sweepRes = cell(nSweeps,1);

            % The model has 4 fit parameters
            nFitParams = 4;

            ppm = doParforProgressStarter('Sweeping...', nSweeps);
            ppm_cleanup = onCleanup(@() delete(ppm));

            % Perform the fits
            plotParam_ = self.plotParam;
            parfor iSweep = 1:nSweeps
                % What are the boundaries for the current fit?
                curBounds = sweepBounds{iSweep};
                curDMin = curBounds(1);
                curDMax = 30;

                % Select the data that falls within the boundaries
                data_d = fd.d(fd.d >= curDMin & fd.d < curDMax); %#ok
                data_f = fd.f(fd.d >= curDMin & fd.d < curDMax);

                fitFd = FdData('', data_f, data_d, 1:length(data_f));

                % Prepare for the fit
                f       = [];
                gof     = [];
                output  = [];

                if length(data_d) > nFitParams
                    % We have enough data points to do a fit.
                    % (If we have fewer data points than 'nFitParams', the
                    % boundaries are too close together, and we can't fit).
                    try
                        [f, gof, output] = fitFun(fitFd); %#ok
                    catch err
                        if strcmp(err.identifier, 'curvefit:fit:nanComputed') ...
                        || strcmp(err.identifier, 'curvefit:fit:complexValueComputed') ...
                        || strcmp(err.identifier, 'curvefit:fit:notEnoughDataPoints')
                            % not getting a fit; that's OK
                        else
                            rethrow(err);
                        end
                    end
                end

                if isempty(f)
                    % Store the fact that this fit failed
                    sweepRes{iSweep} = nan(1,3);
                else
                    % We're keeping track of one param only, for this figure
                    p = zeros(1,3);
                    p(1) = f.(plotParam_);
                    p(2) = output.exitflag;
                    p(3) = gof.rmse;
                    sweepRes{iSweep} = p;
                end

                ppm.increment(iSweep); %#ok
            end


            %% Transform results
            % Store the fit results in a form that's more convenient for
            % plotting later on. That's a struct array with results,
            % with one field per tracked fit parameter value. For example,
            % if we're tracking 'Lp' and 'S', we get:
            % res(i)
            %   .Lp       = vector with fit values
            %   .S        = vector with fit values
            %   .err      = vector with goodness-of-fit values
            %   .exitflag = vector with exit flags of the 'fit' function
            res = struct();
            res.sweepPosL = sweepPosL;

            resParamNames = {self.plotParam 'err' 'exitflag'};
            for iParam = 1:length(resParamNames)
                curParam = resParamNames{iParam};

                res.(curParam) = zeros(nSweeps,1);
                for i = 1:length(sweepPosL)
                    res.(curParam)(i) = sweepRes{i}(iParam);
                end
            end
        end

        function plot(self, varargin)
            % PLOT Create plot.

            plot@Figure(self);

            self.setupAxes();
            self.axes_main = gca();

            plot(...
                self.sweepResults.brokenFits.sweepPosL ./ self.simulLc, ...
                self.sweepResults.brokenFits.(self.plotParam), ...
                'ob', 'MarkerSize', 8 ...
                );
            hold('on');
            plot(...
                self.sweepResults.correctFits.sweepPosL ./ self.simulLc, ...
                self.sweepResults.correctFits.(self.plotParam), ...
                'o', 'Color', [0 0.7 0], 'MarkerSize', 8 ...
                );
            curXLims = xlim();
            plot(...
                curXLims, self.(['simul' self.plotParam]) .* [1 1], ...
                '-', 'Color', [0.8 0.8 0.8] ...
                );

            xlim(curXLims);
            ylim(self.YLims);
            set(gca(), 'YTick', linspace(self.YLims(1), self.YLims(2), 5));

            xlabel('d_{min}/L_c');
            ylabel(self.plotParam);

            addInset();

            function addInset()
                self.axes_inset = axes('Position', [0.19 0.65 0.3 0.25]);

                plottedData     = self.fittedData.subset('d', [-Inf 30]);
                highlightedData = self.fittedData.subset('d', [13 30]);

                plot(...
                    self.axes_inset, plottedData.d, plottedData.f, ...
                    '.', 'Color', [0.7 0.7 0.7] ...
                    );
                hold(self.axes_inset, 'on');
                plot(...
                    self.axes_inset, highlightedData.d, highlightedData.f, ...
                    '.', 'Color', [0 0 0] ...
                    );

                line([13 13], [0 30], 'LineStyle', '--', 'Color', [0.3 0.3 0.3]);

                xlim([10 17]);
                ylim([0 30]);

                set(self.axes_inset, ...
                      'XTick',                  [13] ...
                    , 'XTickLabel',             {'d_{min}'} ...
                    , 'YTick',                  [] ...
                    );
                ylabel('Force');
            end

        end

    end % methods

end

